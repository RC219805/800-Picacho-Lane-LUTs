# Build and Test Workflow

# 

# This workflow provides CI/CD for the 800-Picacho-Lane-LUTs repository with:

# - Multi-version Python testing (3.10, 3.11, 3.12)

# - Fast fail-fast linting before heavy installations

# - CPU-only dependencies to keep CI lean and fast

# - Montecito manifest generation and artifact upload

# 

# Design Goals:

# - Speed: Fast linting gate, efficient caching, minimal deps

# - Reliability: Explicit error handling, disk space management

# - Determinism: Pinned actions, no-cache installs

# 

# Performance Notes:

# - Typical runtime: 2-3 minutes per Python version

# - Cache hit reduces install time by 30-60%

# - Disk cleanup recovers ~10GB

name: build

on:
push:
branches: [ main ]
pull_request:
branches: [ main ]
workflow_dispatch:  # Allow manual triggering

# Cancel in-progress runs for the same PR/branch

concurrency:
group: ${{ github.workflow }}-${{ github.ref }}
cancel-in-progress: true

env:

# Global environment variables for consistency

PYTHONUNBUFFERED: “1”
PYTHONDONTWRITEBYTECODE: “1”
PIP_NO_CACHE_DIR: “1”
PIP_DISABLE_PIP_VERSION_CHECK: “1”

jobs:
build:
name: Test (Python ${{ matrix.python-version }})
runs-on: ubuntu-24.04
timeout-minutes: 15  # Fail fast if hanging

```
strategy:
  # Don't cancel all matrix jobs if one fails
  fail-fast: false
  matrix:
    python-version: [ "3.10", "3.11", "3.12" ]

steps:
  - name: Checkout code
    uses: actions/checkout@v4
    with:
      fetch-depth: 1  # Shallow clone for speed

  - name: Set up Python ${{ matrix.python-version }}
    uses: actions/setup-python@v5
    with:
      python-version: ${{ matrix.python-version }}
      cache: 'pip'  # Built-in pip caching
      cache-dependency-path: 'requirements-ci.txt'

  # Fast lint gate: no heavy deps (runs before any other installs)
  # This provides immediate feedback on syntax errors
  - name: Fast lint gate (flake8 errors only)
    run: |
      python -m pip install --upgrade pip
      pip install --no-cache-dir flake8
      flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
    continue-on-error: false

  # GitHub runners have limited disk space (~14GB available)
  # Clean up unnecessary files to prevent "no space left on device" errors
  - name: Free disk space
    run: |
      echo "=== Disk space before cleanup ==="
      df -h
      
      # Remove large preinstalled packages
      sudo rm -rf /opt/ghc /usr/local/lib/android || true
      sudo rm -rf /opt/hostedtoolcache/CodeQL || true
      sudo rm -rf /usr/share/dotnet || true
      
      echo "=== Disk space after cleanup ==="
      df -h

  # Manual cache for additional control
  # The setup-python cache handles most cases, but this provides fallback
  - name: Cache pip packages
    uses: actions/cache@v4
    with:
      path: ~/.cache/pip
      key: ${{ runner.os }}-pip-${{ hashFiles('requirements-ci.txt') }}-${{ matrix.python-version }}
      restore-keys: |
        ${{ runner.os }}-pip-${{ hashFiles('requirements-ci.txt') }}-
        ${{ runner.os }}-pip-

  # Install only CI-required dependencies (CPU-only, no CUDA)
  # Uses requirements-ci.txt which should be a subset of requirements.txt
  - name: Install lean dependencies (CPU-only)
    env:
      PIP_PROGRESS_BAR: "off"
    run: |
      pip install --no-cache-dir --upgrade pip setuptools wheel
      pip install --no-cache-dir -r requirements-ci.txt
      
      # Verify critical packages are installed
      python -c "import numpy; print(f'numpy {numpy.__version__}')"
      python -c "import PIL; print(f'Pillow {PIL.__version__}')"

  # Show installed packages for debugging
  - name: Show installed packages
    if: runner.debug == '1'
    run: pip list

  # Run tests with pytest
  # -q: Quiet mode (less verbose)
  # --tb=short: Shorter traceback format
  # -v: Verbose (use for debugging)
  - name: Run tests with pytest
    run: |
      pytest -q --tb=short --color=yes
    continue-on-error: false

  # Optional: Run with coverage (can be enabled later)
  # - name: Run tests with coverage
  #   run: |
  #     pip install pytest-cov
  #     pytest --cov=. --cov-report=xml --cov-report=term
  # 
  # - name: Upload coverage to Codecov
  #   uses: codecov/codecov-action@v4
  #   with:
  #     files: ./coverage.xml
  #     flags: unittests
  #     name: codecov-umbrella
```

# Separate job for manifest generation

# Only runs after successful tests

generate-manifest:
name: Build Montecito Manifest
needs: [build]
runs-on: ubuntu-24.04
timeout-minutes: 10

```
steps:
  - name: Checkout code
    uses: actions/checkout@v4
    with:
      fetch-depth: 1

  - name: Set up Python
    uses: actions/setup-python@v5
    with:
      python-version: "3.12"
      cache: 'pip'
      cache-dependency-path: 'requirements-ci.txt'

  - name: Install dependencies
    run: |
      python -m pip install --upgrade pip
      pip install --no-cache-dir -r requirements-ci.txt

  # Robustly handle different manifest tool interfaces
  # Attempts multiple strategies to find the output file
  - name: Generate Montecito manifest
    id: manifest
    shell: bash
    run: |
      set -euo pipefail
      
      echo "=== Running Montecito Manifest Tool ==="
      
      # Default output filename
      OUT="montecito_manifest.json"
      
      # Check if tool accepts --out flag
      if python tools/montecito_manifest.py --help 2>/dev/null | grep -qi -- '--out'; then
        echo "Tool accepts --out flag, using: $OUT"
        python tools/montecito_manifest.py --out "$OUT"
      else
        echo "Tool doesn't accept --out flag, running without args"
        python tools/montecito_manifest.py || {
          echo "Warning: Manifest generation failed, checking for output files..."
        }
      fi
      
      # Verify output file exists, or find most recent JSON
      if [ ! -f "$OUT" ]; then
        echo "Expected output not found, searching for JSON files..."
        CANDIDATE="$(find . -name '*.json' -type f -newer .git -print 2>/dev/null | head -n1 || true)"
        
        if [ -n "$CANDIDATE" ]; then
          OUT="$CANDIDATE"
          echo "Found candidate manifest: $OUT"
        else
          echo "No manifest file found!"
          OUT=""
        fi
      fi
      
      # Export for next step
      echo "manifest_path=$OUT" >> "$GITHUB_OUTPUT"
      
      # Display manifest info if found
      if [ -n "$OUT" ] && [ -f "$OUT" ]; then
        echo "=== Manifest file info ==="
        ls -lh "$OUT"
        echo "=== Manifest preview (first 20 lines) ==="
        head -n 20 "$OUT" || true
      fi

  # Upload manifest as artifact for download
  # Only runs if manifest was successfully generated
  - name: Upload manifest artifact
    if: ${{ steps.manifest.outputs.manifest_path != '' }}
    uses: actions/upload-artifact@v4
    with:
      name: montecito-manifest-${{ github.sha }}
      path: ${{ steps.manifest.outputs.manifest_path }}
      if-no-files-found: error
      retention-days: 30  # Keep for 30 days

  # Post-upload verification
  - name: Verify manifest artifact
    if: ${{ steps.manifest.outputs.manifest_path != '' }}
    run: |
      echo "✅ Manifest generated successfully"
      echo "Artifact name: montecito-manifest-${{ github.sha }}"
      echo "File path: ${{ steps.manifest.outputs.manifest_path }}"

  # Optional: Validate manifest JSON structure
  - name: Validate manifest JSON
    if: ${{ steps.manifest.outputs.manifest_path != '' }}
    run: |
      python -c "
      import json
      import sys
      
      manifest_path = '${{ steps.manifest.outputs.manifest_path }}'
      
      try:
          with open(manifest_path) as f:
              data = json.load(f)
          print(f'✅ Valid JSON with {len(data)} top-level keys')
          
          # Optional: Add schema validation here
          # required_keys = ['version', 'files', 'timestamp']
          # for key in required_keys:
          #     if key not in data:
          #         print(f'❌ Missing required key: {key}')
          #         sys.exit(1)
          
      except json.JSONDecodeError as e:
          print(f'❌ Invalid JSON: {e}')
          sys.exit(1)
      except Exception as e:
          print(f'❌ Error: {e}')
          sys.exit(1)
      "
```

# Summary job that runs after all jobs complete

# Useful for branch protection rules (require single check instead of matrix)

all-checks-passed:
name: All checks passed
if: always()
needs: [build, generate-manifest]
runs-on: ubuntu-latest
steps:
- name: Check build status
if: ${{ needs.build.result != ‘success’ }}
run: |
echo “❌ Build job failed”
exit 1

```
  - name: Check manifest status
    if: ${{ needs.generate-manifest.result != 'success' }}
    run: |
      echo "❌ Manifest generation failed"
      exit 1

  - name: All checks passed
    run: |
      echo "✅ All checks passed successfully!"
      echo "Build: ${{ needs.build.result }}"
      echo "Manifest: ${{ needs.generate-manifest.result }}"
```